// new module script

enum ListItemEnum {
  eFlour, 
  eYeast, 
  eInstantPudding, 
  eChampange, 
  eMusicDisc, 
  
  /* Following items are chaff */
  
  eToothpaste, 
  eTshirt, 
  
  eLastListITem
};


struct ListItemsParamType
{  
  String name;
  String description;
  float price;
  bool selected;
};

/**
 * Should change this when reimporting sprite into a new ID.
 */
readonly int RECIPT_SPRITE = 19;

/**
 * Margin of the whole recipt from top of room.
 */
readonly int TOP_MARGIN = 20;

/**
 * Margin of the whole recipt from right of room.
 */
readonly int RIGHT_MARGIN = 20;

/**
 * Where the first list iten will start on the Y axis
 */
readonly int LIST_START_Y = 85;

/**
 * The vertical location names of the list.
 */
readonly int LIST_ITEMS_X = 10;

/**
 * The vertical location the prices of the list.
 */
readonly int LIST_PRICES_X = 100;

/**
 * Width of a list item including margins
 */
readonly int LIST_ITEM_WIDTH = 15; 

#define COLOR_ITEM_NORMAL Game.GetColorFromRGB(0, 0, 0)
#define COLOR_ITEM_HOVER Game.GetColorFromRGB(255, 255, 0)
#define COLOR_ITEM_SELECTED Game.GetColorFromRGB(150, 150, 150)

Overlay *globRecieptOverlay;
DynamicSprite *globRecieptSprite;

ListItemsParamType globItemPartamters[eLastListITem];
int globHoveredItem;

function game_start() 
{
  globItemPartamters[eFlour].name = "Flour";
  globItemPartamters[eFlour].description = "TODO flur description";
  globItemPartamters[eFlour].price = 1.00;
  
  globItemPartamters[eYeast].name = "Yeast";
  globItemPartamters[eYeast].description = "TODO yeast description";
  globItemPartamters[eYeast].price = 2.00;
  
  globItemPartamters[eInstantPudding].name = "Cream";
  globItemPartamters[eInstantPudding].description = "TODO cream description";
  globItemPartamters[eInstantPudding].price = 3.99;
  
  globItemPartamters[eChampange].name = "Champange";
  globItemPartamters[eChampange].description = "TODO champange description";
  globItemPartamters[eChampange].price = 12.00;
  
  globItemPartamters[eMusicDisc].name = "Music CD";
  globItemPartamters[eMusicDisc].description = "TODO cd description";
  globItemPartamters[eMusicDisc].price = 9.99;
  
  globItemPartamters[eToothpaste].name = "Toothpaste";
  globItemPartamters[eToothpaste].description = "TODO toothpaste description";
  globItemPartamters[eToothpaste].price = 5.00;
  
  globItemPartamters[eTshirt].name = "T Shirt";
  globItemPartamters[eTshirt].description = "TODO t shirt description";
  globItemPartamters[eTshirt].price = 7.50;
  
  globRecieptSprite = DynamicSprite.Create(Game.SpriteWidth[RECIPT_SPRITE], Game.SpriteHeight[RECIPT_SPRITE]);
}


function CalcRecieptLeft()
{
  return Room.Width - Game.SpriteWidth[RECIPT_SPRITE] - RIGHT_MARGIN;
}

function CalcRecieptRight()
{
  return CalcRecieptLeft() + Game.SpriteWidth[RECIPT_SPRITE];
}

function CalcRecieptTop()
{
  return TOP_MARGIN;
}

function CalcRecieptBottom()
{
  return CalcRecieptTop() + Game.SpriteHeight[RECIPT_SPRITE];
}


function ReDraw() {

  DrawingSurface *surface = globRecieptSprite.GetDrawingSurface();
  
  // Note: can resize the sprite here using width and height parameters.
  surface.DrawImage(0, 0,  RECIPT_SPRITE, true); 

  for (int i = 1; i < eLastListITem; i++) {
    
    if (globHoveredItem == i) {
      surface.DrawingColor = COLOR_ITEM_HOVER;
    } else if (globItemPartamters[i].selected) {
      surface.DrawingColor = COLOR_ITEM_SELECTED;
    } else {
      surface.DrawingColor = COLOR_ITEM_NORMAL;
    }
    
    surface.DrawString(
      LIST_ITEMS_X,
      LIST_START_Y + i * LIST_ITEM_WIDTH, 
      eFontfntReciept, 
      globItemPartamters[i].name);
      
    surface.DrawString(
      LIST_PRICES_X,
      LIST_START_Y + i * LIST_ITEM_WIDTH, 
      eFontfntReciept, 
      String.Format("%.2f$", globItemPartamters[i].price));
  }
  
  surface.Release();
  
  // Remove old drawing before re-drawing
  if (globRecieptOverlay != null && globRecieptOverlay.Valid) {
    globRecieptOverlay.Remove();
  }
  
  // Create the actual overlay (will display it on screen)
  globRecieptOverlay = Overlay.CreateGraphical(
    CalcRecieptLeft(),
    CalcRecieptTop(), 
    globRecieptSprite.Graphic,
    true);     
  
}

function DetermineHover()
{
  globHoveredItem = 0;
  
  if (mouse.x < CalcRecieptLeft() || mouse.x > CalcRecieptRight() )
  {
    return;
  }
  
  for (int i = 1; i < eLastListITem; i++) {
    if (mouse.y > LIST_START_Y + i * LIST_ITEM_WIDTH && mouse.y < LIST_START_Y + (i + 1) * LIST_ITEM_WIDTH) {
      globHoveredItem = i;
    }
  }
}

function on_mouse_click(MouseButton button) {
  if (player.HasInventory(iReciept) && globHoveredItem != 0) 
  {
    if (button == eMouseLeft) {
      globItemPartamters[globHoveredItem].selected = ! globItemPartamters[globHoveredItem].selected;
    } else if (button == eMouseRight) {
      player.Say(globItemPartamters[globHoveredItem].description);
    }
  }
}


function repeatedly_execute() 
{
  // TODO: Redraw only when something changes
  if (player.HasInventory(iReciept))
	{
    DetermineHover();
    ReDraw();
	} else if (globRecieptOverlay != null && globRecieptOverlay.Valid) {
		globRecieptOverlay.Remove(); // TODO refactor into function
	}
}